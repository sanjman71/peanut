-# total_days => number of days to show
-# start_day => day to start calendar with
-# today => day to show as 'Today'
-# markings => hash mapping days to markings for that day
-# show_weeks => if true, show weeks, otherwise, just show the day names; defaults to true

-# Calculate how many extra days we need to add at the start, so that the calendar begins on the first day of the week
- start_day = daterange.start_at.in_time_zone.beginning_of_day
- end_day = daterange.end_at.in_time_zone.end_of_day
- total_days = daterange.days
- today = DateRange.today unless local_assigns[:today]
- if current_company
  - extra_days_at_start = (start_day.wday - current_company.preferences[:start_wday].to_i) % 7
  - extra_days_at_end = (((current_company.preferences[:start_wday].to_i - 1) % 7) - end_day.wday) % 7
- else
  - extra_days_at_start = start_day.wday
  - extra_days_at_end = (6 - end_day.wday)
-# split days into weeks, use first week to show calendar header fields
- weeks = Array(0..(total_days-1 + extra_days_at_start + extra_days_at_end)).in_groups_of(7)
- week0 = weeks.first.blank? ? [] : weeks.first.compact

-# always show weeks unless explicitly asked not to
- show_weeks = true if local_assigns[:show_weeks].nil?

%table.calendar
  %tbody
    %tr.colborder
      - week0.each do |day_i|
        -# show Mon-Sun header fields
        - day_string = (start_day + (day_i - extra_days_at_start).days).strftime("%a")
        %th{:class => 'dayname', :id => day_string.downcase, :byday => day_string.downcase.slice(0,2)}= day_string
      - if show_weeks
        -# show appointments for each day
        - weeks.each do |week|
          %tr
            - week.compact.each do |day_i|
              -# compute the day we're on
              - day     = start_day + (day_i - extra_days_at_start).days
              -# check for markings (used as css tags) on this day
              - key     = day.to_s(:appt_schedule_day)
              - klasses = []
              - count   = 0
              - case
              - when markings[key].is_a?(Array)
                - klasses += markings[key]
              - when markings[key].is_a?(Hash)
                - klasses += markings[key][:state]
                - count   = markings[key][:count].to_i
              -# add weekday or weekend class
              - klasses += [0, 6].include?(day.wday) ? ['weekend'] : ['weekday']
              -# add past, today classes based on day of the year
              - klasses += ['past'] if day < today
              - klasses += ['today'] if day == today
              - klasses += ((day >= start_day) && (day <= end_day)) ? ['in-range'] : ['outside-range']
              -# set id as date [year,month,day]
              - id = "#{day.year}#{sprintf("%02d", day.month)}#{sprintf("%02d", day.mday)}"
              %td{:class => klasses.join(" "), :id => id}
                -# special case for 'Today'
                %span= (day == today) ? 'Today' : day.strftime("%b %d")
                %br
                - if count > 0
                  %span{:style => 'font-size: 0.8em;'}= pluralize(count, 'time slot')
              
